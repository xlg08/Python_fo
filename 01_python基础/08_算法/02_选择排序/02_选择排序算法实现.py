"""
    选择排序算法介绍：
        原理：
            每轮都假设该轮最前面的那个元素为最小值，然后去剩下的列表中去寻找真正的最小值。
            最终交换即可。这样就找到了本轮的最小值。重复以上步骤即可
        大白话：
            第一轮，假设i=0位置的元素是最小值，然后用min_index记住其索引，然后去剩下的的元素中
            寻找最小值，找到了用min_index做记录。最终判断i和min_index是否交换。第一轮完毕后。
            最小值就在最小索引处。重复该步骤，直至排序完成。
        分析流程：
            假设5个元素
                第几轮（索引）          概论比较总次数            公式（具体的谁和谁比较）
                第一轮（0）                 4次                   索引0和1,2,3,4比较
                第一轮（1）                 3次                   索引1和2,3,4比较
                第一轮（2）                 2次                   索引2和3,4比较
                第一轮（3）                 1次                   索引3和4比较
        要点：
            1.比较的总轮数                              列表长度 - 1
            2.每轮比较总次数                            i+1 ~ n
            3.谁和谁比较？                      索引min_index（初始i）和索引j比较，索引i和min_index的值交换

"""


"""
    具有三个索引：
        i               当前需要去和其他元素需要比较的元素的位置索引
        min_index       一个过渡的索引  每一次比较完之后最小值所在位置的索引
        j               动态索引，当前和i所在位置的元素进行比较的索引
"""

def select_sort(my_list):
    # 获取列表长度
    n = len(my_list)
    # 外层循环控制轮数
    for i in range(n - 1):
        # 定义变量 min_index ，记录本轮最小值的索引
        min_index = i
        # 内部循环控制每次比较次数
        for j in range(i+1, n):     # 1234    234   34  4
            # 具体的比较过程，索引min_index和索引j进行比较
            if my_list[j] < my_list[min_index]:
                min_index = j
        # 走到此处说明本轮已经找到最小值了，判断，并交换
        if min_index != i:
            my_list[min_index], my_list[i] = my_list[i], my_list[min_index]


if __name__ == '__main__':
    my_list = [5, 3, 4, 7, 2]
    select_sort(my_list)
    print(my_list)






